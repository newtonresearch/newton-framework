DefineGlobalConstant('kGetFrameStuffFunc, plainC.FGetFrameStuff);{/*------------------------------------------------------------------------------	G l o b a l   F u n c t i o n s------------------------------------------------------------------------------*///ее	Math Operators	|+|: plainC.FAdd,								/* freq-func */	|-|: plainC.FSubtract,						/* freq-func */	|*|: plainC.FMultiply,						/* freq-func */	|/|: plainC.FDivide,							/* freq-func */	|div|: plainC.FDiv,							/* freq-func */	|mod|: plainC.FMod,	|negate|: plainC.FNegate,	|not|: plainC.FNot,							/* freq-func */	|=|: plainC.FEqual,							/* freq-func */	|<>|: plainC.FUnorderedLessOrGreater,  /* freq-func */	|<|: plainC.FLessThan,						/* freq-func */	|>|: plainC.FGreaterThan,					/* freq-func */	|>=|: plainC.FGreaterOrEqual,				/* freq-func */	|<=|: plainC.FLessOrEqual,					/* freq-func */	|aref|: plainC.FAref,						/* freq-func */	|setAref|: plainC.FSetAref,				/* freq-func */	|newIterator|: plainC.FNewIterator,		/* freq-func *///ее	Utilities - Object System	ClassOf: plainC.FClassOf,					/* freq-func */	Clone: plainC.FClone,						/* freq-func */	DeepClone: plainC.FDeepClone,	TotalClone: plainC.FTotalClone,	EnsureInternal: plainC.FEnsureInternal,	GetFunctionArgCount: plainC.FGetFunctionArgCount,	GetPath: plainC.FGetPath,	GetSlot: plainC.FGetSlot,	GetVariable: plainC.FGetVariable,	HasPath: plainC.FHasPath,					/* freq-func */	HasSlot: plainC.FHasSlot,	HasVar: plainC.FHasVar,						/* aka exists */	HasVariable: plainC.FHasVariable,	Intern: plainC.FIntern,	IsArray: plainC.FIsArray,	IsBinary: plainC.FIsBinary,	IsCharacter: plainC.FIsCharacter,	IsDirty: plainC.FIsDirty,	IsFrame: plainC.FIsFrame,	IsFunction: plainC.FIsFunction,	IsImmediate: plainC.FIsImmediate,	IsInstance: plainC.FIsInstance,	IsInteger: plainC.FIsInteger,	IsPathExpr: plainC.FIsPathExpr,	IsMagicPtr: plainC.FIsMagicPtr,	IsNativeFunction: plainC.FIsNativeFunction,	IsNumber: plainC.FIsNumber,	IsReadOnly: plainC.FIsReadOnly,	IsReal: plainC.FIsReal,	IsString: plainC.FIsString,	IsSubclass: plainC.FIsSubclass,	IsSymbol: plainC.FIsSymbol,	IsValidString: plainC.FIsValidString,	length: plainC.FLength,						/* freq-func */	MakeBinary: plainC.FMakeBinary,	Map: plainC.FMap,	PrimClassOf: plainC.FPrimClassOf,	RemoveSlot: plainC.FRemoveSlot,	ReplaceObject: plainC.FReplaceObject,	SetClass: plainC.FSetClass,				/* freq-func */	SetVariable: plainC.FSetVariable,	SymbolCompareLex: plainC.FSymbolCompareLex,	SymbolName: plainC.FSymbolName /* funcPtr: 712615, numArgs: 1 */,	ref: plainC.Fref,	refOf: plainC.FrefOf,	ObjectPid: plainC.FObjectPid /* funcPtr: 820416, numArgs: 1 */,	PidToPkgRef: plainC.FPidToPkgRef /* funcPtr: 820480, numArgs: 1 */,	PssidToPkgRef: plainC.FPssidToPkgRef /* funcPtr: 820499, numArgs: 2 */,	PssidToPid: plainC.FPssidToPid /* funcPtr: 820529, numArgs: 2 */,	GetPkgInfoFromPssid: plainC.FGetPkgInfoFromPssid /* funcPtr: 6898180, numArgs: 2 */,	PidToPackage: plainC.FPidToPackage /* funcPtr: 7038752, numArgs: 1 */,	PidToPackageLite: plainC.FPidToPackageLite /* funcPtr: 7038753, numArgs: 1 */,//ее	Utilities - Strings	BeginsWith: plainC.FBeginsWith,	Capitalize: plainC.FCapitalize,	CapitalizeWords: plainC.FCapitalizeWords,	CharPos: plainC.FCharPos,	Downcase: plainC.FDowncase,	EndsWith: plainC.FEndsWith,	EvalStringer: plainC.FEvalStringer /* funcPtr: 711437, numArgs: 2 */,	FindStringInArray: plainC.FFindStringInArray,	FindStringInFrame: plainC.FFindStringInFrame,	FormattedNumberStr: plainC.FFormattedNumberStr /* funcPtr: 7035600, numArgs: 2 */,	IsAlphaNumeric: plainC.FIsAlphaNumeric,	IsWhiteSpace: plainC.FIsWhiteSpace,	CoordinateToLatitude: plainC.FCoordinateToLatitude /* funcPtr: 611513, numArgs: 2 */,	CoordinateToLongitude: plainC.FCoordinateToLongitude /* funcPtr: 611488, numArgs: 2 */,	LatitudeToCoordinate: plainC.FLatitudeToCoordinate /* funcPtr: 611464, numArgs: 2 */,	LongitudeToCoordinate: plainC.FLongitudeToCoordinate /* funcPtr: 611440, numArgs: 2 */,	NumberStr: plainC.FNumberStr /* funcPtr: 7037721, numArgs: 1 */,	ParamStr: plainC.FParamStr /* funcPtr: 7037726, numArgs: 2 */,	SPrintObject: plainC.FSPrintObject,	StrCompare: plainC.FStrCompare /* funcPtr: 6911929, numArgs: 2 */,	StrConcat: plainC.FStrConcat /* funcPtr: 7325242, numArgs: 2 */,	StrConcatDelimited: func(str1, str2, str3) if not StrFilled(str1) then str3 & "" else str1 & str2 & str3,	StrEqual: plainC.FStrEqual,	StrExactCompare: plainC.FStrExactCompare /* funcPtr: 7013411, numArgs: 2 */,	StrFilled: plainC.FStrFilled,	StrFontWidth: func(str, fnt) begin StrLen(str) * 6 end,  /* TEST *///	StrFontWidth: plainC.FStrFontWidth /* funcPtr: 7039824, numArgs: 2 */,	stringer: plainC.FStringer,				/* freq-func */	StringFilter: plainC.FStringFilter /* funcPtr: 7039828, numArgs: 3 */,	StringFilterOut: func(inStr, inFilter)		begin		local filteredStr := SubstituteChars(inStr, inFilter, "\uFFFF");		filteredStr := StringFilter(filteredStr, "\uFFFF", 'rejectAll)		end,	StringToNumber: plainC.FStringToNumber /* funcPtr: 7039830, numArgs: 1 */,	StripDiacriticals: plainC.FStripDiacriticals /* funcPtr: 7013415, numArgs: 1 */,	StripDigits: func(inStr, inNumOfDigits, inFromParenthesis)		begin		local cleanStr := "";		local i := 0, count := StrLen(inStr);		while inNumOfDigits > 0 and i < count do			begin			if inStr[i] >= $0 and inStr[i] <= $9 then				inNumOfDigits := inNumOfDigits - 1			else				cleanStr := cleanStr & inStr[i];			i := i + 1			end;		cleanStr := cleanStr & Substr(inStr, i, nil);		if inFromParenthesis then			begin			i := 0;			while i < count do				begin				if cleanStr[i] >= $0 and cleanStr[i] <= $9 then					begin					if i > 0 and cleanStr[i - 1] = $( then						i := i - 1;					break					end;				i := i + 1				end;			cleanStr := Substr(cleanStr, i, nil)			end;		cleanStr		end,	StrLen: plainC.FStrLen,	StrMunger: plainC.FStrMunger,	StrPos: plainC.FStrPos,	StrPosExact: func(inStr, inSubstr, inStart)		begin		local i := inStart;		while i := StrPos(inStr, inSubstr, i) do			if inStr[i] = inSubstr[0] then				break			else				i := i + 1;		i		end,	StrReplace: plainC.FStrReplace,	StrParse: func(inStr, arg2)		begin		local local1, local2, local3, local4;		local3 := inStr;		local4 := [];		while local1 := StrPos(local3, arg2, 0) do			begin			local2 := Substr(local3, 0, local1);			local3 := Substr(local3, local1 + 1, StrLen(local3));			StrLen(local2) > 0 and AddArraySlot(local4, local2);			end;		if StrLen(local3) > 0 then			AddArraySlot(local4, local3);		local4		end,	StrParseTrimmed: func(inStr, arg2)		begin		local local1, local2, local3;		local2 := [];		foreach local3 in StrParse(inStr, arg2) do			begin			local1 := TrimString(local3);			if StrLen(local3) > 0 then				AddArraySlot(local2, local1);			end;		local2		end,	StrReverse: func(ioStr)		begin		local first := 0;		local last := StrLen(ioStr) - 1;		while first < last do			begin			local ch := ioStr[first];			ioStr[first] := ioStr[last];			ioStr[last] := ch;			first := first + 1;			last := last - 1			end;		return ioStr		end,	StrTokenize: func(inStr, inDelimiters)		begin		/* closed */ local str := inStr;		/* closed */ local delimiters := inDelimiters;		if IsInstance(delimiters, 'char) then			delimiters := delimiters & "";		/* closed */ local pos := 0;		func()			begin			local len := StrLen(str);			if pos < len then				begin				while CharPos(delimiters, str[pos], 0) do					begin					pos := pos + 1;					if pos = len then						return					end;				local start := pos;				repeat					pos := pos + 1				until pos = len or CharPos(delimiters, str[pos], 0);				Substr(str, start, pos - start)				end			end		end,	StyledStrTruncate: plainC.FStyledStrTruncate /* funcPtr: 6997536, numArgs: 3 */,	SubstituteChars: plainC.FSubstituteChars /* funcPtr: 7028202, numArgs: 3 */,	SubStr: plainC.FSubStr,	TrimString: plainC.FTrimString,	TrimTruncatedString: func(str)		begin		local count := StrLen(str);		for i := 0 to count - 1 do			if str[i] = $\00 then				break SetLength(str, 2 * (i + 1))		end,	TryStringLength: plainC.FTryStringLength /* funcPtr: 6997538, numArgs: 0 */,	Upcase: plainC.FUpcase,	ScanWordStart: plainC.FScanWordStart /* funcPtr: 6996507, numArgs: 3 */,	ScanWordEnd: plainC.FScanWordEnd /* funcPtr: 6996506, numArgs: 3 */,	ScanPrevWordEnd: plainC.FScanPrevWordEnd /* funcPtr: 6996505, numArgs: 3 */,	ScanNextWord: plainC.FScanNextWord /* funcPtr: 6996504, numArgs: 3 */,//ее Utilities - Characters	Chr: plainC.FCHR,	Ord: plainC.FORD,	IsAlpha: func(ch) (ch >= $a and ch <= $z) or (ch >= $A and ch <= $Z),	IsDigit: func(ch) ch >= $0 and ch <= $9,	IsLower: func(ch) ch >= $a and ch <= $z,	ToLower: func(ch)		begin		if IsUpper(ch) then			begin			local str := SPrintObject(ch);			Downcase(str);			ch := str[0]			end;		ch		end,	Lower: plainC.FLower /* funcPtr: 6874943, numArgs: 1 */,	IsUpper: func(ch) ch >= $A and ch <= $Z,	ToUpper: func(ch)		begin		if IsLower(ch) then			begin			local str := SPrintObject(ch);			Upcase(str);			ch := str[0]			end;		ch		end,//ее	Utilities - Bitwise	band: plainC.FBitAnd,						/* freq-func */	bor: plainC.FBitOr,							/* freq-func */	bxor: plainC.FBitXor,	bnot: plainC.FBitNot,						/* freq-func *///ее	Utilities - Array	addArraySlot: plainC.FAddArraySlot,		/* freq-func */	Array: plainC.FArray,	ArrayInsert: plainC.FArrayInsert,	ArrayMunger: plainC.FArrayMunger,	ArrayRemoveCount: plainC.FArrayRemoveCount,	InsertionSort: plainC.FInsertionSort /* funcPtr: 811584, numArgs: 3 */,	LFetch: plainC.FLFetch,	LSearch: plainC.FLSearch,	NewWeakArray: plainC.FNewWeakArray /* funcPtr: 712702, numArgs: 1 */,	SetAdd: plainC.FSetAdd /* funcPtr: 6911914, numArgs: 3 */,	SetContains: plainC.FSetContains /* funcPtr: 6911916, numArgs: 2 */,	SetDifference: plainC.FSetDifference /* funcPtr: 6911917, numArgs: 2 */,	SetLength: plainC.FSetLength,	SetOverlaps: plainC.FSetOverlaps /* funcPtr: 6911920, numArgs: 2 */,	SetRemove: plainC.FSetRemove /* funcPtr: 6911922, numArgs: 2 */,	SetUnion: plainC.FSetUnion /* funcPtr: 6911924, numArgs: 3 */,	Sort: plainC.FSort,	StableSort: plainC.FStableSort /* funcPtr: 806624, numArgs: 3 */,//ее	Utilities - Sorted Array	BDelete: plainC.FBDelete /* funcPtr: 810654, numArgs: 5 */,	BDifference: plainC.FBDifference /* funcPtr: 811407, numArgs: 4 */,	BFetch: plainC.FBFetch /* funcPtr: 810915, numArgs: 4 */,	BFetchRight: plainC.FBFetchRight /* funcPtr: 810854, numArgs: 4 */,	BFind: plainC.FBFind /* funcPtr: 810794, numArgs: 4 */,	BFindRight: plainC.FBFindRight /* funcPtr: 810738, numArgs: 4 */,	BInsert: plainC.FBInsert /* funcPtr: 810555, numArgs: 5 */,	BInsertRight: plainC.FBInsertRight /* funcPtr: 810458, numArgs: 5 */,	BIntersect: plainC.FBIntersect /* funcPtr: 811370, numArgs: 5 */,	BMerge: plainC.FBMerge /* funcPtr: 811338, numArgs: 5 */,	BSearchLeft: plainC.FBSearchLeft /* funcPtr: 810361, numArgs: 4 */,	BSearchRight: plainC.FBSearchRight /* funcPtr: 810259, numArgs: 4 */,//ее	Utilities - Integer Math	abs: plainC.Fabs /* funcPtr: 6907709, numArgs: 1 */,	ceiling: plainC.Fceiling /* funcPtr: 6908751, numArgs: 1 */,	floor: plainC.Ffloor /* funcPtr: 6909813, numArgs: 1 */,	max: plainC.FMax,	min: plainC.FMin,	LimitInt: func(n, lo, hi) if n < lo or n > hi then nil else floor(n),	PinInt: func(n, lo, hi) if n < lo then lo else if n > hi then hi else floor(n),	|<<|: plainC.FLShift,	|>>|: plainC.FRShift,	Real: plainC.FReal /* funcPtr: 6911908, numArgs: 1 */,	Random: plainC.FRandom /* funcPtr: 6911907, numArgs: 2 */,	SetRandomSeed: plainC.FSetRandomSeed /* funcPtr: 7039808, numArgs: 1 */,	GetRandomState: plainC.FGetRandomState /* funcPtr: 714065, numArgs: 0 */,	SetRandomState: plainC.FSetRandomState /* funcPtr: 714105, numArgs: 1 */,//ее Utilities - Floating Point Math	acos: plainC.Facos /* funcPtr: 6912979, numArgs: 1 */,	acosh: plainC.Facosh /* funcPtr: 6912980, numArgs: 1 */,	asin: plainC.Fasin /* funcPtr: 6912982, numArgs: 1 */,	asinh: plainC.Fasinh /* funcPtr: 6912983, numArgs: 1 */,	atan: plainC.Fatan /* funcPtr: 6912984, numArgs: 1 */,	atan2: plainC.Fatan2 /* funcPtr: 6912985, numArgs: 2 */,	atanh: plainC.Fatanh /* funcPtr: 6912986, numArgs: 1 */,	copysign: plainC.Fcopysign /* funcPtr: 6912988, numArgs: 2 */,	cos: plainC.Fcos /* funcPtr: 6912989, numArgs: 1 */,	cosh: plainC.Fcosh /* funcPtr: 6912990, numArgs: 1 */,	erf: plainC.Ferf /* funcPtr: 6914016, numArgs: 1 */,	erfc: plainC.Ferfc /* funcPtr: 6914017, numArgs: 1 */,	exp: plainC.Fexp /* funcPtr: 6914018, numArgs: 1 */,	expm1: plainC.Fexpm1 /* funcPtr: 6914019, numArgs: 1 */,	fabs: plainC.Ffabs /* funcPtr: 6914020, numArgs: 1 */,	fdim: plainC.Ffdim /* funcPtr: 6912991, numArgs: 2 */,	fmax: plainC.Ffmax /* funcPtr: 6914044, numArgs: 2 */,	fmin: plainC.Ffmin /* funcPtr: 6914045, numArgs: 2 */,	fmod: plainC.Ffmod /* funcPtr: 6914032, numArgs: 2 */,	gamma: plainC.Fgamma /* funcPtr: 6914033, numArgs: 1 */,	hypot: plainC.Fhypot /* funcPtr: 6914034, numArgs: 2 */,	isfinite: plainC.Fisfinite /* funcPtr: 6914035, numArgs: 1 */,	IsFiniteNumber: plainC.FIsFiniteNumber /* funcPtr: 6914035, numArgs: 1 */,	isnan: plainC.Fisnan /* funcPtr: 6914036, numArgs: 1 */,	isnormal: plainC.Fisnormal /* funcPtr: 6914037, numArgs: 1 */,	LessEqualOrGreater: plainC.FLessEqualOrGreater /* funcPtr: 6910867, numArgs: 2 */,	LessOrGreater: plainC.FLessOrGreater /* funcPtr: 6910868, numArgs: 2 */,	lgamma: plainC.Flgamma /* funcPtr: 6914039, numArgs: 1 */,//	log: plainC.Flog /* funcPtr: 6914040, numArgs: 1 */,	logb: plainC.Flogb /* funcPtr: 6914043, numArgs: 1 */,	log1p: plainC.Flog1p /* funcPtr: 6914042, numArgs: 1 */,	log10: plainC.Flog10 /* funcPtr: 6914041, numArgs: 1 */,	nearbyint: plainC.Fnearbyint /* funcPtr: 6914046, numArgs: 1 */,	nextafterd: plainC.Fnextafterd /* funcPtr: 6914047, numArgs: 2 */,	pow: plainC.Fpow /* funcPtr: 6914048, numArgs: 2 */,	randomx: plainC.Frandomx /* funcPtr: 6914049, numArgs: 1 */,	remainder: plainC.Fremainder /* funcPtr: 6914050, numArgs: 2 */,	remquo: plainC.Fremquo /* funcPtr: 6914051, numArgs: 2 */,	rint: plainC.Frint /* funcPtr: 6914052, numArgs: 1 */,	rinttol: plainC.Frinttol /* funcPtr: 6914053, numArgs: 1 */,	round: plainC.Fround /* funcPtr: 6914054, numArgs: 1 */,	scalb: plainC.Fscalb /* funcPtr: 6914055, numArgs: 2 */,	signbit: plainC.Fsignbit /* funcPtr: 6914056, numArgs: 1 */,	signum: plainC.Fsignum /* funcPtr: 6911926, numArgs: 1 */,	sin: plainC.Fsin /* funcPtr: 6914057, numArgs: 1 */,	sinh: plainC.Fsinh /* funcPtr: 6914058, numArgs: 1 */,	sqrt: plainC.Fsqrt /* funcPtr: 6914059, numArgs: 1 */,	tan: plainC.Ftan /* funcPtr: 6914060, numArgs: 1 */,	tanh: plainC.Ftanh /* funcPtr: 6914061, numArgs: 1 */,	trunc: plainC.Ftrunc /* funcPtr: 6914062, numArgs: 1 */,	Unordered: plainC.FUnordered /* funcPtr: 6912969, numArgs: 2 */,	UnorderedGreaterOrEqual: plainC.FUnorderedGreaterOrEqual /* funcPtr: 6912970, numArgs: 2 */,	UnorderedLessOrEqual: plainC.FUnorderedLessOrEqual /* funcPtr: 6912971, numArgs: 2 */,	UnorderedOrEqual: plainC.FUnorderedOrEqual /* funcPtr: 6912972, numArgs: 2 */,	UnorderedOrGreater: plainC.FUnorderedOrGreater /* funcPtr: 6912973, numArgs: 2 */,	UnorderedOrLess: plainC.FUnorderedOrLess /* funcPtr: 6912974, numArgs: 2 */,//ее Utilities - Floating Point Environment	feclearexcept: plainC.Ffeclearexcept /* funcPtr: 6914021, numArgs: 1 */,	fegetenv: plainC.Ffegetenv /* funcPtr: 6914022, numArgs: 0 */,	fegetexcept: plainC.Ffegetexcept /* funcPtr: 6914023, numArgs: 1 */,	feholdexcept: plainC.Ffeholdexcept /* funcPtr: 6914025, numArgs: 1 */,	feraiseexcept: plainC.Fferaiseexcept /* funcPtr: 6914026, numArgs: 1 */,	fesetenv: plainC.Ffesetenv /* funcPtr: 6914027, numArgs: 1 */,	fesetexcept: plainC.Ffesetexcept /* funcPtr: 6914028, numArgs: 2 */,	fetestexcept: plainC.Ffetestexcept /* funcPtr: 6914030, numArgs: 1 */,	feupdateenv: plainC.Ffeupdateenv /* funcPtr: 6914031, numArgs: 1 */,	fegetround: plainC.Ffegetround /* funcPtr: 6914024, numArgs: 0 */,	fesetround: plainC.Ffesetround /* funcPtr: 6914029, numArgs: 1 */,//ее Utilities - Financial	annuity: plainC.Fannuity /* funcPtr: 6912981, numArgs: 2 */,	compound: plainC.Fcompound /* funcPtr: 6912987, numArgs: 2 */,//ее Utilities - Exceptions	Throw: plainC.FThrow/*name, data*/,	Rethrow: plainC.FRethrow,	CurrentException: plainC.FCurrentException,	IsSubexception: plainC.FIsSubexception/*name, super*/,	ThrowBadTypeWithFrameData: func(errCode, errValue)		Throw('|evt.ex.fr.intrp;type.ref.frame|, {errorCode: errCode, value: errValue}),	RethrowWithUserMessage: func(title, msg, arg3)		begin		local xName, xData;		local x := CurrentException();		if x.data then			begin			xName := x.name;			if IsFrame(x.data) then				begin				if not arg3 and x.data.userMessage then					Rethrow();				xData := Clone(x.data);				xData._userTitle := title;				xData._userMessage := msg				end			else				xData := {_userTitle: title, _userMessage: msg, _origExData: x.data}			end;		else if x.message then			begin			xName := '|evt.ex;type.ref|;			xData := {_userTitle: title, _userMessage: msg, message: x.message}			end		else			begin			xName := Intern(x.name & ";type.ref");			if x.error then				xData := {_userTitle: title, _userMessage: msg, errorCode: x.error}			else				xData := {_userTitle: title, _userMessage: msg}			end;		Throw(xName, xData)		end,//ее Utilities - Message Sending	Apply: plainC.FApply,	Perform: plainC.FPerform,	PerformIfDefined: plainC.FPerformIfDefined,	ProtoPerform: plainC.FProtoPerform,	ProtoPerformIfDefined: plainC.FProtoPerformIfDefined,	CallWithStrokesOff: func(fn, args)		begin		try			BlockStrokes();			local result := Apply(fn, args);		onexception |evt.ex| do			begin			UnblockStrokes();			FlushStrokes();			Rethrow()			end;		UnblockStrokes();		FlushStrokes();		result		end,	SendWithStrokesOff: func(rcvr, msg, args)		begin		try			BlockStrokes();			local result := Perform(rcvr, msg, args);		onexception |evt.ex| do			begin			UnblockStrokes();			FlushStrokes();			Rethrow()			end;		UnblockStrokes();		FlushStrokes();		result		end,//ее Utilities - Deferred Message Sending//	IsHalting: although documented, doesn╒t appear to exist	AddDeferredCall: plainC.FAddDeferredCall,	AddDeferredSend: plainC.FAddDeferredSend,	AddDelayedCall: plainC.FAddDelayedCall,	AddDelayedSend: plainC.FAddDelayedSend,	AddProcrastinatedCall: func(fnSym, fnObj, args, delay)		begin		local action := procrastinatedActions.(fnSym);		local timeToRun := Ticks() + delay * 60 div 1000;		if action then			begin			local isProcastinated := timeToRun < action.timeToRun;			action.receiverOrClosure := fnObj;			action.argArray := args;			action.message := nil;			action.timeToRun := timeToRun;			if isProcastinated then				AddDelayedCall(functions.ExecuteProcrastinatedCall, [fnSym], delay)			end		else			begin			procrastinatedActions.(EnsureInternal(fnSym)) := {	receiverOrClosure: fnObj,																				argArray: args,																				message: nil,																				timeToRun: timeToRun };			AddDelayedCall(functions.ExecuteProcrastinatedCall, [fnSym], delay)			end;		timeToRun	end,	AddProcrastinatedSend: func(msgSym, rcvr, msg, args, delay)		begin		local action := procrastinatedActions.(msgSym);		local timeToRun := Ticks() + delay * 60 div 1000;		if action then			begin			action.receiverOrClosure := rcvr;			action.argArray := args;			action.message := msg;			action.timeToRun := timeToRun			end		else			begin			procrastinatedActions.(EnsureInternal(msgSym)) := {receiverOrClosure: rcvr,																				argArray: args,																				message: msg,																				timeToRun: timeToRun };			AddDelayedCall(functions.ExecuteProcrastinatedCall, [msgSym], delay)			end		end,	ExecuteProcrastinatedCall: func(arg1)		begin		local action := ProcrastinatedActions.(arg1);		if action then			begin			local delay := action.timeToRun - Ticks();			if delay > 0 then				AddDelayedCall(functions.ExecuteProcrastinatedCall, [arg1], delay * 1000 div 60);			else				begin				RemoveSlot(ProcrastinatedActions, arg1);				if action.message then					Perform(action.receiverOrClosure, action.message, action.argArray)				else					Apply(action.receiverOrClosure, action.argArray)				end			end		end,	AddPrecludedCall: func(fnSym, fnObj, args, delay)		begin		if not procrastinatedActions.(fnSym) then			AddProcrastinatedCall(fnSym, fnObj, args, delay)		end,	AddPrecludedSend: func(msgSym, rcvr, msg, args, delay)		begin		if not ProcrastinatedActions.(msgSym) then			AddProcrastinatedSend(msgSym, rcvr, msg, args, delay)		end,//ее Utilities - Data Extraction	ExtractChar: plainC.FExtractChar/*obj, offset*/,	ExtractUniChar: plainC.FExtractUniChar/*obj, offset*/,	ExtractByte: plainC.FExtractByte/*obj, offset*/,	ExtractWord: plainC.FExtractWord/*obj, offset*/,	ExtractLong: plainC.FExtractLong/*obj, offset*/,	ExtractXLong: plainC.FExtractXLong/*obj, offset*/,	ExtractCString: plainC.FExtractCString/*obj, offset*/,	ExtractPString: plainC.FExtractPString/*obj, offset*/,	ExtractBytes: plainC.FExtractBytes/*obj, offset, length, class*/,//ее Utilities - Data Stuffing	StuffChar: plainC.FStuffChar/*obj, offset, data*/,	StuffUniChar: plainC.FStuffUniChar/*obj, offset, data*/,	StuffByte: plainC.FStuffByte/*obj, offset, data*/,	StuffWord: plainC.FStuffWord/*obj, offset, data*/,	StuffLong: plainC.FStuffLong/*obj, offset, data*/,	StuffCString: plainC.FStuffCString/*obj, offset, str*/,	StuffPString: plainC.FStuffPString/*obj, offset, str*/,//ее Utilities - Getting and Setting Globals	DefGlobalFn: plainC.FDefGlobalFn,	UnDefGlobalFn: func(inTag)			begin RemoveSlot(functions, inTag); nil end,	GetGlobalFn: func(inTag)			functions.(inTag),	GlobalFnExists: func(inTag)		HasSlot(functions, inTag),	DefGlobalVar: func(inTag, inValue)  vars.(EnsureInternal(inTag)) := inValue,	UnDefGlobalVar: func(inTag)		begin RemoveSlot(vars, inTag); nil end,	GetGlobalVar: func(inTag)			vars.(inTag),	GlobalVarExists: func(inTag)		HasSlot(vars, inTag),//ее Utilities - Debugging	Print: plainC.FPrint,	Write: plainC.FWrite,	BadWickedNaughtyNoot: func(inErr, inReason)		begin		local msg := if IsInteger(inErr) then			"Nasty practice #" & inErr & (if inReason then $( & inReason & $)) & $\n		else			"\nUse of " & inReason & " API:\n-  " & inErr & $\n;		if vars.noEvilLiveOn then			begin			Write(msg);			BreakLoop()			end		else if inReason <> 'obsolete then			Write(msg)		end,	DebugHashToName: func(inHash) // should really be installed by debug package		begin		local index := LSearch('[646, 5075, 90824, 11538576, 362838, 1448480, 728989, 11541917, 23283101, 2911004, 280740, 1444304, 5800980, 5775968, 2887824, 5826406, 46622864, 45415, 90112, 45085, 90867, 72801, 724016, 90529, 45061, 2904837, 181408, 182001, 181520, 363081, 22568, 11340, 360639, 5572, 5605, 21708, 1222, 17692, 46168208, 5800646, 361046, 71574, 1144630, 5438275, 2323, 2356, 5802140, 1451, 4529, 16733, 2574, 23027604, 90204, 726132, 37436, 97212, 23994396, 78008, 2542296, 2182, 2888314, 757625, 1444048, 722074, 1451126, 46321264, 723740, 46240, 21728, 11649, 2288, 1031, 188577, 628, 8790, 739977, 20601, 32890, 363708, 272060, 16989, 585660, 71773, 263868, 8413, 352956, 22045, 44040, 265948, 657, 303504, 1527504, 40025, 160442, 381876, 81529, 642633, 320500, 186553, 23370, 4266, 10410, 16702, 314703, 43078, 156619, 19835, 19866, 158172, 5930, 165658, 21204266, 119418192, 5301797, 16503, 741783, 9693, 9476, 143920, 1392176, 9104503, 42186, -382561072, 156805, 350698, 265274, 43969, 2161822, 3041, 192553, 18827, 4641, 93364, 371716, 8256, 9385, 4777060, 759704, 8249, 5463, 4384, 46632, 8205, 16513, 4121, 165689, 8221, 153023, 78425, 2752, 78400, 9281, 9392, 308009, 10726, 10554, 2737449, 23255048, 186293128, 89299848, 78458, 5019632, 71132, 1264988, 346713, 2511770, 2511739, 79248, 72912, 148080, 557905, 9289008, 346592, 18867984, 267472, 10055132, 2618844, 1377180, 84057, 84043, 45552, 38757, 77100, 11369, 2122537, 78502, 42665, -329551966, 362187, 8817, 93808, 17357, 18635, 156971, 80875, 87352533, 2936, 16887, 22697, 67840, 2909404, 71595, 45916, 75348, 2375, 4189, 18952, 2336, 5552, 2716, 18878, 9203, 1405, 595, 22287, 19734, 87889, 6040, 286, 2649, 85068, 41826, 331701, 8554065, 133473, 269199, 269208, 534565, 724748, 362739, 725250, 725147, 5223, 2533, 176528, 77405, 10185, 319180, 17422, 40867024, 10222800, 157285, 2115625, 5802460, 136028, 2105737, 33744, 35824, 81047, 11086, 22842, 371049, 2406, 8202, 16397, 611997, 33484, 8425, 1075909, 4238277, 8553925, 33488, 32865, 42299, 4176, 8342, 1450448, 77968, 65936, 161680, 574352, 714576, 2862800, 42000, 157264, 40020, 299128, 149728, 1301114, 22162, 4711, 20475, 162496, 16478, 2598, 4294, 20913, 167787, 81963, 165669, 83237, 20914, 41617, 5245, 10553, 2658, 41677, 20915, 5196, 334792, 19857600, 167410, 83638, 20916, 668673, 1337236, 5313940, 20917, 85652, 43430, 264614, 2727334, 2546086, 5104, 556342, 5461302, 57008, 2901296, 17209715, 37368179, 37393237, 1546772, 2651810, 41095, 279519, 41951, 43746, 16845, 20235, 21933, 77307, 147023, 187855, 2839247, 77148, 85311, 72709794, 1135751, 1555963, 569673], inHash, 0, '|=|, nil);		if index then '["root", "buttons", "protoBorder", "protoPictureButton", "protoCloseBox", "protoStaticText", "protoInputLine", "protoRichInputLine", "protoLabelInputLine", "protoLabelPicker", "entryLineIcon", "protoTextButton", "protoCheckboxIcon", "protoRadioCluster", "protoRadioButton", "protoIconCheckBox", "protoIconRadioButton", "protoGauge", "protoSlider", "protoTable", "protoGlance", "analogClock", "protoStatusBar", "protoStatus", "protoTitle", "protoBottomTitle", "protoDivider", "protoDragNGo", "protoFloater", "protoFloatNGo", "ProtoRoll", "protoApp", "protoRollItem", "polygon", "picture", "paragraph", "group", "clipboard", "protoPictRadioButton", "protoCategorylist", "protoTextList", "contentList", "contentPictList", "textListScrollers", "AZTabs", "AZVert", "protoNumberPicker", "years", "decades", "centuries", "poptop", "PeriodicAlarmEditor", "protoPicker", "protoCorrector", "NetChooser", "zoneChooser", "printerSerialPicker", "notify roll", "notificationRoll", "msgBox", "protoRoutingSlip", "stringDataView", "protoSendButton", "protoRouteSlip", "protoFormatList", "protoTransportHeader", "protoTransport", "statusText", "titleText", "progress", "barber", "gauge", "stop primary", "icon", "closeBox", "statusTemplate", "secondary", "filingSlip", "protoKeyboard", "alphaKeyboard", "alphaKeys", "numberKeyboard", "numericKeys", "datesKeyboard", "dateKeys", "phoneKeyboard", "phoneKeys", "phoneKeys2", "AddressPicker", "Show", "IORouteButton", "TransportButton", "IOItemView", "IOItemLayout", "transportIcon", "IOEntryView", "IOEmbeddedView", "IOItemViewDef", "PrintPreview", "PrintSlip", "FaxSlip", "willDial", "faxAssist", "ManualDialing", "TitleLabel", "NoteContents", "NotesArea", "NotesSlip", "NotesContent", "ZapSlip", "ScheduleSlip", "scheduleslip cancel", "scheduleslip schedule button", "ScheduleSlipTitle", "DateValue", "StartStopValue", "Invitees", "Location", "MtgMsgHeader", "SeriesMsgHeader", "FirstLastDateValue", "RemindSlip", "remindslip cancel button", "MeetingTitle", "toSubjectSlip", "addresseeSlip", "worldClock", "calculatorkeypad", "Styles", "WritingStyle", "inputArea", "metrics", "TryEasyWord", "TryHarderWord", "calendar", "cribView", "cribMoreIndicator", "UpDownScroller", "dateView", "weeknum", "divider", "Status Bar", "DatesNew", "DatesShow", "DayView", "scheduleView", "DayTable", "HeaderLabels", "MeetingView", "Slider", "MeetingText", "CribNote", "CribText", "MonthOverview", "ToDoList", "ToDoSlip", "ToDoListOverview", "protoCalendarFinder", "protoMeetingSoupFinder", "protoRepeatingMeetingSoupFinder", "MeetingSlip", "MeetingSlipHeader", "AlarmPicker", "FrequencyPicker", "RepeatingView", "MeetingNotesSlip", "MeetingNotesArea", "NotesButton", "doit button", "AskThisOrAll", "DeleteRMDialog", "ChangeDialogHeader", "RepeatCluster", "ConfirmChangeButton", "cancel button", "MeetingAlarmPicker", "EventAlarmPicker", "WeekStartPicker", "WarningView", "WarningTime", "protoMonth", "MonthTitle", "monthInYear", "YearView", "calendarOverview", "MeetingList", "ToDoAgenda", "protoCalendarPrintFormat", "protoPrintDay", "divider1", "PrintHeader", "DayOfWeek", "CribFrame", "MeetingFrame", "ExtrasFrame", "RemoveOldMeetingsForm", "prompt", "DaysValue", "protoBook", "Copperfield", "protoFuncContent", "contentArea", "subContent", "markuplayer", "Browse", "Outline", "broscroll", "BroBar", "showBar", "picker", "markupBtn", "bookmark", "page#", "info", "pgRouting", "ctrlPanel", "page#Dialog", "writein", "ofN", "pgDlog", "remoteThumb", "pageFormat", "pageRangeForm", "canonicalTextBlock", "canonCompass", "canonScrollee", "canonScroller", "canonicalTitle", "protoStoryCard", "protoBookmark", "protoBookAbout", "protoBookPrefs", "TinyTim", "dTitle", "topicsButton", "HelpOutline", "ListView", "assist drawer", "actionBox", "assist cancel button", "assist doit button", "AssistFrames", "cityTimeOverview", "protoConfigPicker", "DevicePicker", "CallSlipTemplate", "callButton", "LCD Screen", "KeyedDigits", "PhonePad", "QuickDial", "SpeakerToggle", "Hangup", "CallSlip", "Demo Data", "OnlineServices", "FindDrawer", "findDate", "findGlobalRadio", "findSelectedRadio", "findFrontmostRadio", "findButton", "findStatus", "selectApps", "FindAll", "findlist", "protoNullButton", "NamesButton", "DatesButton", "ExtrasButton", "OverviewButton", "ScrollUpButton", "ScrollDownButton", "UndoButton", "AssistButton", "mailEditor", "messageHolder", "messageField", "mailRoutingSlip", "smartMail", "message", "MailPrefs", "mailRegister", "cancelBtn", "regBtn", "backBtn", "register1", "regFirstName", "regLastName", "regHomePhone", "regDayPhone", "register2", "regAddress", "regCity", "regState", "regZip", "regCountry", "register3", "regCard", "regCardNumber", "CreditExperRegister", "regCardFirst", "regCardLast", "register4", "regCertificate", "regCertPassword", "regBackupPassword", "register5", "regPassword", "ReviewDict", "AddReviewDict", "RemoveReviewDict", "ExpandReviewDict", "AutoAdd", "AddAutoAddDict", "RemoveAutoAddDict", "a2zIndexer", "zero2nineIndexer", "kUCBlockCharSetInfo", "kStandardCharSetInfo", "HWRecPreferencesForm", "userStyleOption", "soundPickerPopup", "SoundGauge", "ActionEffects", "PenEffects", "sleepPopup", "countries", "keyboards", "paperSize", "modemVolume", "blinddialing", "pulseDialing", "touchtonedialing", "modemPicker", "RemoveModem", "alarmSoundPickerPopup", "AlarmSoundGauge", "useSystemVolume", "AnnoyingAlarms"][index]		end,	BreakLoop: plainC.FBreakLoop,	ExitBreakLoop: plainC.FExitBreakLoop,	DV: plainC.FDV,	GC: plainC.FGC,	StackTrace: plainC.FStackTrace,	Stats: plainC.FStats,//	GetHeapStats: plainC.FGetHeapStats /* funcPtr: 527357, numArgs: 1 */,	StrHexDump: plainC.FStrHexDump/*data, width*/,	Uriah: plainC.FUriah,	UriahBinaryObjects: plainC.FUriahBinaryObjects,	Compile: plainC.FCompile/*string*/,	Disassemble: plainC.FDisasm/*functionObject*/,	ObjectSize:	func(inObject, ioResults, arg3, inPath)		begin		if IsImmediate(inObject) or IsReadOnly(inObject) then			return;		if ioResults.reference and inObject = ioResults.reference then			AddArraySlot(ioResults.capture,  {  path: Clone(inPath),															object: inObject,															class: ClassOf(inObject),															size: 0,															sizeAll: 0 });		if SetContains(arg3, inObject) then			return;		local objSize, objPath;		local objClass := ClassOf(inObject);		if ClassOf(objClass) = 'int then			(objClass := 'map);		if IsImmediate(objClass) then			return;		local initialSize := ioResults.objects.size;		SetAdd(arg3, inObject, true);		local primObjClass := PrimClassOf(inObject);		if IsSubclass(objClass, 'string) then			(objClass := 'string);		if {  rectangle: true,				line: true,				roundrectangle: true,				oval: true,				wedge: true,				region: true,				polygon: true,				text: true,				picture: true }.(objClass) then			objClass := 'shape;		if not HasSlot(ioResults, objClass) then			objClass := primObjClass;		if primObjClass = 'frame then			begin			local frameMap := call kGetFrameStuffFunc with (inObject, 0);			if frameMap then				begin				objPath := Clone(inPath);				AddArraySlot(objPath, 'map);				ObjectSize(frameMap, ioResults, arg3, objPath)				end;			local faultSoup := call kGetFrameStuffFunc with (inObject, 1);			if faultSoup then				begin				objPath := Clone(inPath);				AddArraySlot(objPath, 'faultSoup);				ObjectSize(faultSoup, ioResults, arg3, objPath)				end;			foreach tag, obj in inObject do				if tag <> '_parent and tag <> 'viewCObject then					begin					if not IsReadOnly(tag) then						begin						objPath := Clone(inPath);						AddArraySlot(objPath, 'slot);						ObjectSize(tag, ioResults, arg3, objPath)						end;					if not IsImmediate(obj) and not IsReadOnly(obj) then						begin						objPath := Clone(inPath);						AddArraySlot(objPath, tag);						ObjectSize(obj, ioResults, arg3, objPath)						end					end;			if HasSlot(inObject, 'viewCObject) then				begin				local obj := inObject.viewCObject;				if obj then					begin					obj := inObject:ChildViewFrames();					if Length(obj) > 0 then						begin						objPath := Clone(inPath);						AddArraySlot(objPath, 'kids);						ObjectSize(inObject:ChildViewFrames(), ioResults, arg3, objPath)						end					end				end;			objSize := 12 + Length(inObject) * 4			end		else if primObjClass = 'array then			begin			foreach tag, obj in inObject do				if not IsImmediate(obj) and not IsReadOnly(obj) then					begin					objPath := Clone(inPath);					AddArraySlot(objPath, tag);					ObjectSize(obj, ioResults, arg3, objPath);					end;			objSize := 12 + Length(inObject) * 4			end		else if primObjClass = 'binary then			objSize := Length(inObject) + 12		else			objSize := 0;		if primObjClass <> 'frame and not IsReadOnly(objClass) then			begin			objPath := Clone(inPath);			AddArraySlot(objPath, 'binary);			ObjectSize(objClass, ioResults, arg3, objPath)			end;		ioResults.(objClass).count := ioResults.(objClass).count + 1;		ioResults.(objClass).size := ioResults.(objClass).size + objSize;		ioResults.objects.count := ioResults.objects.count + 1;		ioResults.objects.size := ioResults.objects.size + objSize;		if ioResults.capture = 'print then			nil		else			ioResults.capture and (not ioResults.reference and (ioResults.filter <> 'all and ioResults.filter <> 'allKids and objClass = ioResults.filter or ioResults.filter = 'all or ioResults.filter = 'allKids)			 and AddArraySlot(ioResults.capture, { path: Clone(inPath),																object: inObject,																class: objClass,																size: objSize,																sizeAll: ioResults.objects.size - initialSize }))		end,	TrueSize: func(inObject, inFilter)		begin		local object := inObject;		local results := {	objects: {count: 0, size: 0},									binary: {count: 0, size: 0},									frame: {count: 0, size: 0},									array: {count: 0, size: 0},									string: {count: 0, size: 0},									symbol: {count: 0, size: 0},									bitmap: {count: 0, size: 0},									shape: {count: 0, size: 0},									map: {count: 0, size: 0},									real: {count: 0, size: 0},									instructions: {count: 0, size: 0},									capture: [],									reference: nil,									filter: inFilter };		if not inFilter then			results.capture := nil;		else if ClassOf(inFilter) <> 'symbol then			begin			results.reference := inFilter;			results.filter := nil			end;		local local3;		if object = nil then			begin			object := { undo: [  call kGetFrameStuffFunc with (object, 2),										call kGetFrameStuffFunc with (object, 3) ],							root: GetRoot(),							vars: vars };			local3 := []			end		else if object = vars then			local3 := [GetRoot()]		else if object = GetRoot() then			local3 := [vars]		else			local3 := [GetRoot(), vars];		ObjectSize(object, results, local3, SetClass([], 'pathExpr));		local logger := func(inPrintDef)			begin			local curLength := 0;			for i := 1 to Length(inPrintDef) by 2 do				begin				local tabLength := inPrintDef[i - 1];				if curLength < tabLength then					Write(Substr("                                             ", 0, tabLength - curLength));				curLength := tabLength;				if i < Length(inPrintDef) then					begin					local oneLine := SubstituteChars(Stringer([inPrintDef[i]]), "\n", " ");					Write(oneLine);					end				else					return;				curLength := curLength + StrLen(oneLine)				end;			Write("\n")			end;		foreach tag, item in results do			if ClassOf(item) = 'frame and tag <> 'reference and item.count > 0 then				call logger with ([0, tag, 20, item.count, 35, item.size]);		if inFilter then			begin			local captured := Clone(results.capture);			Sort(captured, '|>|, if inFilter = 'allKids then 'sizeAll else 'size);			if inFilter <> 'all and inFilter <> 'allKids then				Write("\n" & inFilter & "\n");			foreach item in captured do				begin				local pathStr := nil;				foreach element in item.path do					if ClassOf(element) = 'int then						pathStr := pathStr & $[ & element & $]					else						pathStr := pathStr & $. & element;				if StrFilled(pathStr) and pathStr[0] = $. then					pathStr := Substr(pathStr, 1, nil);				if ClassOf(inFilter) <> 'symbol then					call logger with ([2, item.class, 20, "", 30, pathStr]);				else					call logger with ([2, item.size, 10, item.sizeAll, 18, item.class, 30, "", 40, pathStr]);			end		end;		if not inFilter then			results		end,	ExtractData: plainC.FExtractData /* funcPtr: 7035591, numArgs: 3 */,	ViewAutopsy: plainC.FViewAutopsy,//	StdioOn: plainC.FStdioOn /* funcPtr: 7213199, numArgs: 0 */,//	StdioOff: plainC.FStdioOff /* funcPtr: 7213198, numArgs: 0 */,	SetDebugMode: plainC.FSetDebugMode/*debugOn*/,	Debug: plainC.Fdebug/*viewContext*/,	DebugMemoryStats: plainC.FDebugMemoryStats,	DebugRunUntilIdle: plainC.FDebugRunUntilIdle,//	PreInitSerialDebugging: plainC.FPreInitSerialDebugging /* funcPtr: 7013408, numArgs: 3 */,//	InitSerialDebugging: plainC.FInitSerialDebugging /* funcPtr: 7260761, numArgs: 2 */,//	ActivateTestAgent: plainC.FActivateTestAgent /* funcPtr: 7212130, numArgs: 2 */,//	DeactivateTestAgent: plainC.FDeactivateTestAgent /* funcPtr: 566271, numArgs: 0 */,//	TestMStartTestCase: plainC.FTestMStartTestCase /* funcPtr: 567795, numArgs: 1 */,//	TestMStartTestFrame: plainC.FTestMStartTestFrame /* funcPtr: 567548, numArgs: 2 */,//	TestMSetParameterString: plainC.FTestMSetParameterString /* funcPtr: 567363, numArgs: 3 */,//	TestMGetReportMsg: plainC.FTestMGetReportMsg /* funcPtr: 567816, numArgs: 0 */,//	TestMDropConnection: plainC.FTestMDropConnection /* funcPtr: 567838, numArgs: 0 */,//	TestReadDataFile: plainC.FTestReadDataFile /* funcPtr: 7213197, numArgs: 3 */,//	TestReadTextFile: plainC.FTestReadTextFile /* funcPtr: 7212138, numArgs: 3 */,//	TestReportError: plainC.FTestReportError /* funcPtr: 7212139, numArgs: 1 */,//	TestReportMessage: plainC.FTestReportMessage /* funcPtr: 7212140, numArgs: 1 */,//	TestFlushReportQueue: plainC.FTestFlushReportQueue /* funcPtr: 7212135, numArgs: 0 */,//	TestGetParameterArray: plainC.FTestGetParameterArray /* funcPtr: 7212136, numArgs: 0 */,//	TestGetParameterString: plainC.FTestGetParameterString /* funcPtr: 7212137, numArgs: 0 */,//	TestExit: plainC.FTestExit /* funcPtr: 7013416, numArgs: 0 */,//	TestWillCallExit: plainC.FTestWillCallExit /* funcPtr: 7013417, numArgs: 0 */,	GetUnitStartTime: plainC.FGetUnitStartTime /* funcPtr: 7036648, numArgs: 1 */,	GetUnitEndTime: plainC.FGetUnitEndTime /* funcPtr: 7036647, numArgs: 1 */,	GetUnitUpTime: plainC.FGetUnitUpTime /* funcPtr: 7017663, numArgs: 1 */,	GetUnitDownTime: plainC.FGetUnitDownTime /* funcPtr: 7017662, numArgs: 1 */,//ее Stroke Journal	JournalStartRecord: plainC.FJournalStartRecord /* funcPtr: 254972, numArgs: 2 */,	JournalStopRecord: plainC.FJournalStopRecord,	JournalReplayALine: plainC.FJournalReplayALine /* funcPtr: 255153, numArgs: 6 */,	JournalReplayAStroke: plainC.FJournalReplayAStroke /* funcPtr: 255052, numArgs: 6 */,	JournalReplayStrokes: PlainC.JournalReplayStrokes /* funcPtr: 255451, numArgs: 4 */,	JournalReplayBusy: plainC.FJournalReplayBusy,//ее NTK	NTKAlive: plainC.FntkAlive,	NTKDownload: plainC.FntkDownload/*connectionKind, machineName, inputTranslator, outputTranslator*/,	NTKListener: plainC.FntkListener/*start, connectionKind, machineName, inputTranslator, outputTranslator*/,	NTKSend: plainC.FntkSend/*object*/,	ntpDownloadPackage: plainC.FpkgDownload/*connectionKind, machineName*/,	ntpTetheredListener: plainC.FSetUpTetheredListener/*start, connectionKind, machineName*/,//ее Utilities - Miscellaneous	AddMemoryItem: func(memSym, value)		AddMemoryItemUnique(memSym, value, nil),	AddMemoryItemUnique: func(memSym, value, testFn)		begin	DefineGlobalConstant('kRef4208D5, func(arg1)		begin		Sort(arg1, func(arg1, arg2)			begin			local local1 := Time() div 1440;			if 16 >> (local1 - arg1.when) + 8 * arg1.count > 16 >> (local1 - arg2.when) + 8 * arg2.count then				-1			else				1			end, nil)		end);			if not memSym or not value or (IsInstance(value, 'string) and not StrFilled(value)) then			return;		local memSlot := GetMemorySlot(memSym, 'make);		if memSlot then			begin			local memItems := memSlot.items;			local local3 := nil;			foreach slot in memItems do				begin				local3 := if testFn	then call testFn with (slot.item, value)											else StrEqual(slot.item, value);				if local3 then					begin					if testFn then						slot.item := Clone(value);					slot.when := Time() div 1440;					slot.count := slot.count + 1;					call kRef4208D5 with (memItems);					break					end				end;			if not local3 then				begin				call kRef4208D5 with (memItems);				ArrayInsert(memItems, {item: Clone(value), when: Time() div 1440, count: 1}, 0);				if Length(memItems) > 8 then					SetLength(memItems, 8);				end;			EntryChange(memSlot)			end		end,	BackLight: plainC.FBackLight /* funcPtr: 7052519, numArgs: 1 */,	BackLightStatus: plainC.FBackLightStatus /* funcPtr: 7052518, numArgs: 0 */,	BinEqual: plainC.FBinEqual,	BinaryMunger: plainC.FBinaryMunger,	BusyBoxControl: plainC.FBusyBoxControl /* funcPtr: 800635, numArgs: 1 */,	Gestalt: plainC.FGestalt /* funcPtr: 7035602, numArgs: 1 */,	RegisterGestalt: plainC.FRegisterGestalt /* funcPtr: 7038766, numArgs: 4 */,	ReplaceGestalt: plainC.FReplaceGestalt /* funcPtr: 7038768, numArgs: 4 */,	GetAppName: func(appSym)		begin		local app := GetRoot().(appSym);		if app and IsInstance(app.appName, 'string) then			app.appName		else if app and IsInstance(app.title, 'string) then			app.title		else			begin			local pkg := GetRoot().extrasDrawer:SetExtrasInfo(appSym, { });			if pkg then				pkg.text			else				SymbolName(appSym)			end		end,	GetAppParams: func()		{  appAreaGlobalTop: displayParams.appAreaGlobalTop,			appAreaGlobalLeft: displayParams.appAreaGlobalLeft,			appAreaTop: displayParams.appAreaTop,			appAreaLeft: displayParams.appAreaLeft,			appAreaWidth: displayParams.appAreaWidth,			appAreaHeight: displayParams.appAreaHeight,			appAreaBounds: displayParams.appAreaBounds,			buttonBarBounds: displayParams.buttonBarBounds,			buttonBarPosition: displayParams.buttonBarPosition },	GetAppPrefs: func(appSym, defaults)		begin	/*	local sysSoup := GetStores()[0]:GetSoup(ROM_systemSoupName);		local appStr := SymbolName(appSym);		local cursor := sysSoup:Query({indexPath: 'tag, beginKey: appStr, endKey: appStr});		local prefs := cursor:Entry();		if prefs then			prefs		else if defaults then			begin			prefs := Clone(defaults);			if not prefs.tag then				prefs.tag := appStr;			sysSoup:Add(prefs)			end	*/ defaults						/* TEST */		end,	GetMemoryItems: func(memSym)		begin		local memSlot := GetMemorySlot(memSym, nil);		if memSlot then			memSlot.items		end,	GetMemorySlot: func(memSym, op)		begin		if memSym then			begin			local memSoup := GetStores()[0]:GetSoup(ROM_systemSoupName);			local memStr := "_M_" & memSym;			local cursor := memSoup:Query({indexPath: 'tag, beginKey: memStr, endKey: memStr});			local memItem := cursor:Entry();			if op = 'remove then				EntryRemoveFromSoup(memItem);			else if memItem then				memItem			else if op = 'make then				begin				memItem := {tag: memStr, items: []};				memSoup:Add(memItem);				memItem				end			end		end,	AddToSysSoup: func(arg1)		begin		local local1 := GetStores()[0]:GetSoup(ROM_systemSoupName);		local1:Add(arg1)		end,	GetTaggedEntry: func(arg1)		begin		local local1, local2;		/* closed */ local key;		key := arg1;		local1 := GetStores()[0]:GetSoup(ROM_systemSoupName);		local2 := Query(local1, {type: 'index, indexPath: 'tag, startKey: key, validTest: func(arg1)											StrEqual(arg1.tag, key) });		local2:Entry()		end,	SaveDataToEntry: func(arg1, arg2)		begin		local local1 := GetTaggedEntry(arg2);		if arg1 then			(if not local1 then				begin				local1 := {tag: arg2, data: arg1};				AddToSysSoup(local1)				end;			else				begin				local1.data := arg1;				EntryChange(local1)				end)		else			local1 and EntryRemoveFromSoup(local1)		end,	MakePhone: func(phoneFrame)		begin		local filter := "()x";		if StrFilled(phoneFrame.areacode) then			phoneFrame.areacode := StringFilterOut(phoneFrame.areacode, filter);		if StrFilled(phoneFrame.phone) then			phoneFrame.phone := StringFilterOut(phoneFrame.phone, filter);		if StrFilled(phoneFrame.extension) then			phoneFrame.extension := StringFilterOut(phoneFrame.extension, filter);		ParamStr("^?0(^0)||^1^?2x^2||", [phoneFrame.areacode, phoneFrame.phone, phoneFrame.extension])		end,	ParsePhone: func(phoneStr)		begin		local local1, local2, local3, local4, local5, local6;		local3 := 0;		local1 := StrPosExact(phoneStr, "(", local3);		if local1 and (local2 := StrPosExact(phoneStr, ")", local3)) then			begin			local4 := Substr(phoneStr, local1 + 1, local2 - local1 - 1);			local3 := local2 + 1;			end;		if (local2 := StrPosExact(phoneStr, "ext", local3))		or (local2 := StrPosExact(phoneStr, "ex", local3))		or (local2 := StrPosExact(phoneStr, "x", local3)) then			local6 := StringFilter(Substr(phoneStr, local2, StrLen(phoneStr) - local2), "ext", 'rejectBeginning)		else			local2 := StrLen(phoneStr);		{areacode: local4, phone: Substr(phoneStr, local3, local2 - local3), extension: local6}		end,	StrToPhone: func(phoneStr)		begin		constant kRef4D2B51 := ",,,,";		local local1;		if StrFilled(phoneStr) then			begin			local1 := Clone(phoneStr);			local1 := SubstituteChars(local1, "ADGJMPTWBEHKNRUXCFILOSVY", "23456789");			StrReplace(local1, "ext", kRef4D2B51, nil);			StrReplace(local1, "ex", kRef4D2B51, nil);			StrReplace(local1, "x", kRef4D2B51, nil);			StringFilter(local1, "abcdefghijklmnoqrstuvyz", 'rejectAll)			end		else			""		end,	MakeDisplayPhone: func(arg1)	begin		local local1, local2;		if IsFrame(arg1) then			(local1 := arg1);		else (if IsInstance(arg1, 'string) then			(local1 := ParsePhone(arg1));		else			return);		local2 := GetUserConfig('phoneFormat);		if not local2 then			(local2 := "^?0^0 ||^1^?2x^2||");		ParamStr(local2, [local1.areacode, local1.phone, local1.extension])	end,	ConvertIntToPhone: func(arg1)	begin		local local1, local2;		local2 := "-";		if not IsInstance(arg1, 'string) then		begin			local1 := SPrintObject(arg1);			if StrLen(local1) = 7 then				StrMunger(local1, 3, 0, local2, 0, Length(local2));			local1		end;		else			arg1	end,	GenPhoneTypes: plainC.FGenPhoneTypes /* funcPtr: 6874917, numArgs: 1 */,	PhoneIndexToValue: plainC.FPhoneIndexToValue /* funcPtr: 6875979, numArgs: 2 */,	PhoneStringToValue: plainC.FPhoneStringToValue /* funcPtr: 6875981, numArgs: 2 */,	PhoneSymToIndex: plainC.FPhoneSymToIndex /* funcPtr: 6875982, numArgs: 2 */,	PhoneSymToString: plainC.FPhoneSymToString /* funcPtr: 6875983, numArgs: 1 */,	PowerOff: func(reason)		begin		if poweringOff then			return;		poweringOff := true;		if not reason then			reason := 'because;		AddDeferredCall(functions.PowerOffSoodan, [reason]);		true		end,	PowerOffSoodan: func(reason)		begin		if not poweringOff then			return;		HideBatteryAlerts();		if not powerOffFenceSitters and PowerOffJooHooShuuShuu(reason) then			PowerOffYobiKaiGi(reason)		end,	PowerOffJooHooShuuShuu: func(reason)		begin		foreach handler in oldPowerOffHandlers do			try			if not handler:PowerOffScript('okToPowerOff) then				poweringOff := nil;			onexception |evt.ex| do				begin				end;		foreach tag, handler deeply in powerOffRegistry do			if handler = powerOffRegistry.(tag) then				try					if not call handler with ('okToPowerOff, reason) then						poweringOff := nil;				onexception |evt.ex| do					begin					end;		true		end,	PowerOffYobiKaiGi: func(reason)		begin		if not poweringOff or poweringOff = 'inYobiKaiGi then			return;		if not powerOffFenceSitters then			begin			foreach handler in OldPowerOffHandlers do				try					handler:PowerOffScript('PowerOff)			onexception |evt.ex| do			begin			end;			powerOffFenceSitters := [];			SetClass(powerOffFenceSitters, reason);			foreach tag, handler deeply in PowerOffRegistry do				if handler = powerOffRegistry.(tag) then					AddArraySlot(powerOffFenceSitters, tag);			end;		if not reason then			reason := ClassOf(powerOffFenceSitters);		poweringOff := 'inYobiKaiGi;		while powerOffFenceSitters and Length(powerOffFenceSitters) > 0 do			begin			local3 := powerOffFenceSitters[0];			local5 := nil;			try				local5 := call PowerOffRegistry.(local3) with ('PowerOff, reason)			onexception |evt.ex| do			begin			end;			if powerOffFenceSitters and Length(powerOffFenceSitters) > 0 and powerOffFenceSitters[0] = local3 then				(if local5 = 'holdYourHorses then			begin				poweringOff := true;			end;			else				SetRemove(powerOffFenceSitters, local3));			end;		powerOffFenceSitters := nil;		poweringOff := nil;		local status := PowerOffRingiSho();		/* the system is now powered off -- we resume here when woken */		PowerOnSequence(status);		true	end,	PowerOffResume: func(arg1)		begin		if powerOffFenceSitters and powerOffFenceSitters[0] = arg1 then			begin			RemoveSlot(powerOffFenceSitters, 0);			AddDeferredCall(functions.PowerOffYobiKaiGi, [ nil ]);			end;		nil		end,	PowerOffRingiSho: plainC.FPowerOff /* funcPtr: 7038762, numArgs: 0 */,	BookAvailable: plainC.FBookAvailable /* funcPtr: 7022942, numArgs: 2 */,	BookRemoved: plainC.FBookRemoved /* funcPtr: 7022943, numArgs: 1 */,	OpenBook: func(id) GetRoot().copperfield:OpenBook(id),	OpenBookTo: func(id, topic)		begin		local c := GetRoot().copperfield;		c:OpenBook(id);		c:TurnToSubject(topic)		end,	OpenHelpBook: func(appSym) GetRoot().tinyTim:OpenHelpBook(appSym),	OpenHelpBookTo: func(appSym, topic) GetRoot().tinyTim:OpenHelpBookTo(appSym, topic),	OpenHelpTo: func(topic) GetRoot().tinyTim:OpenHelpTo(topic),	ShowManual: func() GetRoot().tinyTim:Open(),	Sleep: plainC.FSleep/*numOfMilliseconds*/,	TableLookup: plainC.FTableLookup/*table, key*/,//ееееееее	SetRamParaData: plainC.FSetRamParaData /* funcPtr: 7109580, numArgs: 2 */,	AddHist: plainC.FAddHist /* funcPtr: 6873859, numArgs: 1 */,	Hist: plainC.FHist /* funcPtr: 6874925, numArgs: 1 */,	ExtractRichStringFromParaSlots: plainC.FExtractRichStringFromParaSlots /* funcPtr: 507746, numArgs: 4 */,	AddTryString: plainC.FAddTryString /* funcPtr: 6994389, numArgs: 1 */,	ClearTryString: plainC.FClearTryString /* funcPtr: 6995435, numArgs: 0 */,	InTryString: plainC.FInTryString /* funcPtr: 6996485, numArgs: 1 */,	MatchedChar: plainC.FMatchedChar /* funcPtr: 7028195, numArgs: 2 */,	PathToRoot: plainC.FPathToRoot /* funcPtr: 6875977, numArgs: 1 */,	StringAnnotate: plainC.FStringAnnotate /* funcPtr: 6875995, numArgs: 2 */,	StringShorten: plainC.FStringShorten /* funcPtr: 6877024, numArgs: 1 */,	StringToFrame: plainC.FStringToFrame /* funcPtr: 6877025, numArgs: 1 */,	UniqueAppend: plainC.FUniqueAppend /* funcPtr: 6877031, numArgs: 2 */,	AppendList: plainC.FAppendList /* funcPtr: 6877031, numArgs: 2 */,	MashLists: plainC.FMashLists /* funcPtr: 6877032, numArgs: 2 */,	UnmatchedWords: plainC.FUnmatchedWords /* funcPtr: 6877034, numArgs: 0 */,	Display: plainC.FDisplay /* funcPtr: 6908759, numArgs: 1 */,	GetSortId: plainC.FGetSortId /* funcPtr: 7251237, numArgs: 1 */,	SetSortId: plainC.FSetSortId /* funcPtr: 7251238, numArgs: 1 */,	ShellSort: plainC.FShellSort /* funcPtr: 811542, numArgs: 3 */,	QuickSort: plainC.FQuickSort /* funcPtr: 806974, numArgs: 3 */,	QuickLookDone: plainC.FQuickLookDone /* funcPtr: 7038765, numArgs: 1 */,	GetHilitedTextItems: plainC.FGetHilitedTextItems /* funcPtr: 7051482, numArgs: 0 */,	ReFlow: plainC.FReFlow /* funcPtr: 432026, numArgs: 4 */,	ReflowPreflight: plainC.FReflowPreflight /* funcPtr: 7031389, numArgs: 1 */,	MapSymToFrame: plainC.FMapSymToFrame /* funcPtr: 6875969, numArgs: 1 */,	LookupCompletions: plainC.FLookupCompletions /* funcPtr: 6996488, numArgs: 3 */,	GetChar: plainC.FGetChar /* funcPtr: 7027165, numArgs: 2 */,	CompositeClass: plainC.FCompositeClass /* funcPtr: 6873870, numArgs: 1 */,	MakeLexEntry: plainC.FMakeLexEntry /* funcPtr: 6875968, numArgs: 1 */,	BubbleArraySlot: plainC.FBubbleArraySlot /* funcPtr: 7034538, numArgs: 3 */,	SmartCFQuery: plainC.FSmartCFQuery /* funcPtr: 6874926, numArgs: 1 */,	DrawDateLabels: plainC.FDrawDateLabels /* funcPtr: 7034559, numArgs: 2 */,	GetInsertionStyle: plainC.FGetInsertionStyle /* funcPtr: 7027166, numArgs: 0 */,	SetClipboard: plainC.FSetClipboard /* inClipboard */,	GetClipboard: plainC.FGetClipboard,	GetClipboardIcon: plainC.FGetClipboardIcon,	IsProtocolPartInUse: plainC.FIsProtocolPartInUse /* funcPtr: 821228, numArgs: 1 */,	CalcInkBounds: plainC.FCalcInkBounds /* funcPtr: 7017652, numArgs: 1 */,	MoveCorrectionInfo: plainC.FMoveCorrectionInfo /* funcPtr: 7037709, numArgs: 3 */,	RecognizeTextInStyles: plainC.FRecognizeTextInStyles /* funcPtr: 7052512, numArgs: 2 */,	PostAndDo: plainC.FPostAndDo /* funcPtr: 179766, numArgs: 1 */,	PostCommand: plainC.FPostCommand /* funcPtr: 7038760, numArgs: 2 */,	PostCommandParam: plainC.FPostCommandParam /* funcPtr: 7038759, numArgs: 3 */,	collect: plainC.Fcollect /* funcPtr: 6908754, numArgs: 2 */,	forLoop: plainC.FforLoop /* funcPtr: 6909814, numArgs: 3 */,	setPath: plainC.FsetPath /* funcPtr: 6911921, numArgs: 3 */,	getSiblingSlot: plainC.FgetSiblingSlot /* funcPtr: 6909820, numArgs: 2 */,	hasSiblingSlot: plainC.FhasSiblingSlot /* funcPtr: 6910850, numArgs: 2 */,	GetVar: plainC.FGetVar /* funcPtr: 6910848, numArgs: 1 */,	localVar: plainC.FlocalVar /* funcPtr: 6910870, numArgs: 1 */,	Load: plainC.FLoad /* funcPtr: 6910869, numArgs: 1 */,	StyleArrayContainsInk: plainC.FStyleArrayContainsInk /* funcPtr: 522613, numArgs: 1 */,	FavorAction: plainC.FFavorAction /* funcPtr: 6873887, numArgs: 1 */,	FavorObject: plainC.FFavorObject /* funcPtr: 6874912, numArgs: 1 */,	GetRelevantTemplates: plainC.FGetRelevantTemplates /* funcPtr: 6874922, numArgs: 1 */,	MarkSlotBusy: func(inSymbol, index, inName)		begin		ArrayInsert(busySlots[index], EnsureInternal({appSymbol: inSymbol, appName: inName}), 0);		true		end,	MarkSlotNotBusy: func(inSymbol, index)		begin		local slotRefs := busySlots[index];		local index := LSearch(slotRefs, inSymbol, 0, '|=|, 'appSymbol);		if index then			begin			RemoveSlot(slotRefs, index);			true			end		end,	IsSlotBusy: func(index)	begin		local slotRefs := busySlots[index];		if Length(slotRefs) > 0 then			begin			local name := slotRefs[0].appName;			if name then				name			else				'because			end		end,	GetDynamicValue: plainC.FGetDynamicValue /* funcPtr: 7036649, numArgs: 3 */,	CorrectSelect: plainC.FCorrectSelect /* funcPtr: 6961626, numArgs: 2 */,	GetWordArray: plainC.FGetWordArray /* inUnit */,	ValidateWord: plainC.FValidateWord /* funcPtr: 6997540, numArgs: 2 */,	StripRecognitionWordDiacritsOK: plainC.FStripRecognitionWordDiacritsOK /* funcPtr: 7045147, numArgs: 1 */,	Subsume: plainC.FSubsume /* funcPtr: 6873863, numArgs: 2 */,	FastStrLookup: plainC.FFastStrLookup /* funcPtr: 6873886, numArgs: 1 */,	NumInkWordsInRange: plainC.FNumInkWordsInRange /* funcPtr: 7037720, numArgs: 3 */,	RepeatInfoToText: plainC.FRepeatInfoToText /* funcPtr: 6967965, numArgs: 3 */,	LookupTitle: func(inArray, inTitle)		begin		local foundItem;		foreach item in inArray do			if StrEqual(item.title, inTitle) then				begin				foundItem := item;				break;				end;		foundItem		end,	WordUnitToWordInfo: plainC.FWordUnitToWordInfo /* funcPtr: 179759, numArgs: 1 */,	StringFormat: plainC.FStringFormat /* funcPtr: 7013413, numArgs: 1 */,	StripRecognitionWord: plainC.FStripRecognitionWord /* funcPtr: 6996509, numArgs: 1 */,	ViewWorksWithCombCorrector: plainC.FViewWorksWithCombCorrector /* funcPtr: 7054627, numArgs: 1 */,	InsertStyledText: plainC.FInsertStyledText /* funcPtr: 6996487, numArgs: 5 */,	ClickLetterScript: plainC.FClickLetterScript /* funcPtr: 7044052, numArgs: 1 */,	CountLetters: plainC.FCountLetters /* funcPtr: 7044053, numArgs: 0 */,	DrawLetterScript: plainC.FDrawLetterScript /* funcPtr: 7044054, numArgs: 0 */,	GetLetterHilite: plainC.FGetLetterHilite /* funcPtr: 7044057, numArgs: 0 */,	SetLetterHilite: plainC.FSetLetterHilite /* funcPtr: 7044061, numArgs: 1 */,	getIndexChar: plainC.FgetIndexChar /* funcPtr: 7044058, numArgs: 1 */,	getLetterIndex: plainC.FgetLetterIndex /* funcPtr: 7044059, numArgs: 1 */,	GetSelectionStack: plainC.FGetSelectionStack /* funcPtr: 7053599, numArgs: 0 */,	DrawOriginal: plainC.FDrawOriginal /* funcPtr: 6995441, numArgs: 2 */,	SetChar: plainC.FSetChar /* funcPtr: 7028199, numArgs: 3 */,	MapCursor: plainC.FMapCursor /* funcPtr: 7037707, numArgs: 2 */,	GetRamParaData: plainC.FGetRamParaData /* funcPtr: 7109579, numArgs: 1 */,	SortByClass: func(arg1, arg2, arg3)		begin		/* closed */ local classes, path;		classes := arg2;		path := arg3;		StableSort(arg1, '|<|, func(item)			begin			local obj := if path then				item.(path);			else				item;			local index := LSearch(classes, ClassOf(obj), 0, '|=|, nil);			if index then				index			else				10000			end)		end,	GenPhrases: plainC.FGenPhrases /* funcPtr: 6874914, numArgs: 1 */,	GenSubStrings: plainC.FGenSubStrings /* funcPtr: 6874915, numArgs: 1 */,	CalcBundleBounds: plainC.FCalcBundleBounds /* funcPtr: 7017651, numArgs: 1 */,	GetEditArray: plainC.FGetEditArray /* funcPtr: 6995450, numArgs: 1 */,	MapRect: plainC.FMapRect /* funcPtr: 7010221, numArgs: 3 */,	MapPtX: plainC.FMapPtX /* funcPtr: 7010219, numArgs: 3 */,	MapPtY: plainC.FMapPtY /* funcPtr: 7010220, numArgs: 3 */,	ScaleX: func(arg1, arg2, arg3)	begin		local local1;		local1 := arg1;		local1 := local1 - arg2.left;		local1 := local1 / (arg2.right - arg2.left);		local1 := local1 * (arg3.right - arg3.left);		local1 := local1 + arg3.left;		return floor(round(local1))	end,	GetRangeText: plainC.FGetRangeText /* funcPtr: 7051479, numArgs: 3 */,	Append: plainC.FAppend /* funcPtr: 6873860, numArgs: 2 */,	Intersect: plainC.FIntersect /* funcPtr: 6873862, numArgs: 2 */,	CommonAncestors: plainC.FCommonAncestors /* funcPtr: 6873869, numArgs: 2 */,	MeasuredNumberStr: plainC.FMeasuredNumberStr /* funcPtr: 7028196, numArgs: 3 */,	ReBoot: plainC.FReBoot /* funcPtr: 334526, numArgs: 0 */,	BootSucceeded: plainC.FBootSucceeded /* funcPtr: 799791, numArgs: 1 */,	RunInitScripts: plainC.FRunInitScripts /* funcPtr: 7038771, numArgs: 0 */,}